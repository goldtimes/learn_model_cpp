# 关联容器
底层使用二叉数来实现，每个节点都有父节点和子节点，左子数都小于父节点，而右子数大于父节点
* set/multiset
set/multiset默认根据value的值排序，而set容器不能含有相同的元素，multi可以
* map/multimap
map/multimap 中的每个元素都是pair(key/value)对象，根据key值排序，key不可以重复。而map容器不能含有相同的元素，multimap可以
```c++
#include <iostream>
#include <map>
#include <set>
using namespace std;
int main() {
  multiset<string> cities{"GuangZhou", "ShenZhen", "HangZhou", "Foshan"};
  for (const auto &city : cities) {
    cout << city << " ";
  }
  cout << endl;
  cities.insert({"ZheJiang", "JiangXi", "ShenZhen"});
  for (const auto &city : cities) {
    cout << city << " ";
  }
  cout << endl;

   multimap<int, string> coll;
  // key必须为常量
  int a = 1;
  // 首先是根据key的值排序，其次如何key为变量，如果某个地方修改了，那么整个map就变了
  // 所以建议是常量
  coll = {{a, "tagged"},  {2, "a"},  {1, "this"},    {4, "off"},
          {6, "strings"}, {1, "is"}, {3, "multimap"}};
  for (auto elem : coll) {
    cout << elem.second << " ";
  }
  a = 2;
  cout << endl;
  // 这个元素会插值this is 之后
  coll.insert({1, "ang"});
  for (auto elem : coll) {
    cout << elem.second << " ";
  }
  cout << endl;
}
// Foshan GuangZhou HangZhou ShenZhen 
// Foshan GuangZhou HangZhou JiangXi ShenZhen ShenZhen ZheJiang 
// tagged this is a multimap off strings 
// tagged this is ang a multimap off strings 
```
# 无序容器
无序容器底层的实现是通过hash table。link list构成的array,通过hash函数将元素计算落于array的某个位置
优点是查找某个元素是否在容器中，通过模板函数自定义hash算法，和等效元素
* unordered_set/unordered_multiset
* unordered_map/unordered_multimap