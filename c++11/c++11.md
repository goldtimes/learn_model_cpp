# 左值、右值
## 左值 
可以取地址
* 变量名
* 函数名
* "abc"字符串字面量，其他字面量a,1为右值
* 返回 return_type& func()
* ++i, --i; 前置表达式
## 右值
不能取地址
* 纯右值
** 字面量，2.0, 1, 'a'等
** 函数返回值 func();
** i++,i--;
* 将亡值
 即将要消亡的值、要被移动的对象、T&& 函数的返回值、 std::move的返回值
```c++
int a = b+c; // a为左值，b+c为右值

class A{

};

A a;
auto b = std::move(a); //b为将亡值
auto d = static_cast<T&&>(a); // d为将亡值
```
## 移动语言
定义移动构造函数
```c++
class A
{
    public:
        A(int size): size_(size)
        {
            data_ = new int[size];
        }
        A(){}=default;
        A(const A& other)
        {
            size_ = other.size_;
            // data_ = other.data_;  浅拷贝
            // 深拷贝
            data_ = new int[size_];
            memcpy(data_, other.data_[0], other.data[size]);
        }
        // 移动构造函数
        A(A&& a)
        {
            this->data_ = a.data_;
            a.data_ = nullptr;
        }
        ~A()
        {
            delete[] data_;
        }
    private:
        int* data_;
        int size_;
};
int main()
{
    A a(10);
    A c = std::move(a); // 调用移动构造函数

    vector<string> strs;
    vector<string> tmp = std::move(strs);
}
```


# std::function, std::bind, lambda
```c++
#include <functional>
#include <iostream>

//定义一个结构体
struct Foo {
  Foo(int num) : num_(num) {}
  void print_add(int i) const {
    std::cout << "num_+i:" << num_ + i << std::endl;
  }
  int num_;
};

void print_num(int i) { std::cout << "num: " << i << std::endl; }
// 仿函数
struct PrintNum {
  void operator()(int i) { std::cout << "i: " << i << std::endl; }
};

int main() {
  // 定义function包装器，接受返回类型为void,参数为int类型的
  std::function<void(int)> f_display = print_num;
  // 通过包装器调用函数
  f_display(-9);
  // lambda可以直接捕获全局变量
  std::function<void()> f_lambda = []() -> void { print_num(-10); };
  f_lambda();

  auto f = std::bind(print_num, -11);
  f();
  // 接受bind的返回类型，function<>模板实例化中不需要和print_num函数的参数类型一致
  std::function<void()> f_display_12 = std::bind(print_num, 12);
  // f_display_12(); will get error, f_display_12 is void(int)类型
  f_display_12();
  // 实例化Foo类
  const Foo foo(12345);

  //   std::function<void(int)> f_add_display = &Foo::print_add;
  // 绑定类成员函数的时候，在模板实例化时指定类的类型
  std::function<void(const Foo &, int)> f_add_display = &Foo::print_add;
  f_add_display(foo, 1);
  f_add_display(123456, 1);
  // _1占位符表示f_1调用的时候传递过来的参数
  auto f_1 = std::bind(&Foo::print_add, foo, std::placeholders::_1);
  // 必须要传递参数，否则报错
  f_1(0);

  std::function<void(int)> f_add_display_3 =
      std::bind(&Foo::print_add, foo, std::placeholders::_1);
  f_add_display_3(3);

  return 0;
}
```

# thread
```c++

```

# 右值引用的应用——完美转发
引入c++11中的两个概念
* 引用折叠
一旦出现左值引用，优先折叠为左值引用
```c++
typedef const int T;
T& TR;
TR v = 1; v的类型为A& 常量引用
TR& v = 1; v的类型为A& 引用折叠
TR&& v = 1; v的类型为A& 引用折叠

typedef const int T;
T&& TR;
TR v = 1; v的类型为A&&，右值引用，没问题的，引用一个整型的字面量
TR& v = 1; v的类型为A&，引用折叠，左值引用 T&& & -> T&
TR&& v = 1; v的类型为&&, 引用折叠 4个&&->2个&&
```
* 模板对类型的推导
模板函数对类型的推导就比较简单，如果传入的实参是左值 T类型就是T&，传入右值T类型就是T&&。

综合上面两个规则就可以实现完美转发了
```c++

#include <iostream>

using namespace std;
// void runCode(int a) { cout << "值传递调用" << endl; }
void runCode(int &a) { cout << "左值引用传递调用" << endl; }
void runCode(int &&a) { cout << "右值引用调用" << endl; }
void runCode(const int &a) { cout << "常量左值引用调用" << endl; }
void runCode(const int &&a) { cout << "常量右值引用调用" << endl; }

template <typename T> void perfectForward(T &&t) { runCode(forward<T>(t)); }

int main() {
  int a = 0;
  int b = 0;
  const int c = 1;
  const int d = 1;
  perfectForward(a);            // 传入左值
  perfectForward(std::move(b)); // 传入右值
  perfectForward(c);            // 传入常量的左值
  perfectForward(std::move(d)); // 传入常量的右值

  return 0;
}

```

# 自动类型推导 
## auto
## decltype

# 提高类型安全

## 枚举
默认是整数型，所以也可以用宏定义或者const static int Male = 0;这两个其他的方式来定义
enum Gender {Male, Female};
enum {Male, Female}; // 匿名枚举
### 枚举的问题：全局可见性
因为是全局的可见性Type中的General 和 Category的General是一样的，无法编译通过。
```c++
enum Type {General, Light, Medium};
enum Category {General, Pistol}; 
```
### C++ 强枚举类型
* 强类型
* 不会默认等于整型
* 可以指定底层的实现
```c++
enum class Type{General, Light, Medium};
enum class Gategory {General, Pistol};
enmu class Type1 : char {General, Light};
```

## 智能指针——堆内存管理
* weak_ptr
weak_ptr需要用share_ptr去初始化
weak_ptr不增加share_ptr的引用技术，原理是采用一个临时变量去引用share_ptr
weak_ptr没有*,->等重载方法，需要通过lock获取share_ptr,通过share_ptr再去访问。
* shape_ptr
* uniqur_ptr

# 提高性能及操作硬件能力

## 常量表达式
### const 
const 关键字 修饰变量，函数，函数参数，函数返回值等。但是const是运行时候才能确定是不能被修改的量
```c++
// 数组的长度
// 枚举中的值
// switch case中的 case
// 三个都是需要常量值，编译器时期都是需要值
const int getConst() {return 1;}
void const_fun( int  cond)
{
  int a[getConst()]; // 无法通过
  enum {e1 = getConst(), e2}; // 无法通过
  switch (cond)
  {
    case getConst(): // 无法通过
      break;

  }
}
```
### constexpr
* 函数
声明为constexpr的函数条件比较苛刻
1. 单一return返回的语句
2. 函数必须有返回值(不是void)
3. 使用前必须已经有定义
4. return 表达式中不能使用非常量表达式、全局数据。
* 变量
* 类的构造函数
1. 构造函数的函数体必须为空
2. 类的成员变量需要在初始化列表中去初始化，需要用常量表达式
```c++
constexpr int getSize() {return 10;}
const int a = 26; // 运行时常量，一定分配空间
constexpr int age = 26; // 编译器确定的值，如果没有程序使用，也就没有地址分配
constexpr double x = 20.5; 
```
## 变长模板
### 变长函数
c当中使用，c++不建议
### 变长模板类和变长模板函数
```c++
// c++标准库中的tuple
// ...表示该模板是变长的，Elements是模板参数包
template<typename... Elements>
class tuple{};

// 非类型的
template<int... A>
class NoTypeVariadicTemplate{};

// 变长模板，但是有长度限制，因为B声明了是两个类型的模板类
template<typename T1, typename T2> 
class B{};
template<typename... Elements>
class A : private B<Elements...> // Elements... 解包
{

};
A<int,std::string>people; 

// 那么如何想tuple一样可以接受任意多个呢？
// 模板的偏特化
template<typename... Elements>
class tuple; // 声明变长模板
template<typename Head, typename... Tail> // 偏特化定义
class tuple<Head, Tail...> : private tuple<Tail...>
{
  Head head;
}
// 递归的结束边界条件
template<>
class tuple<>
{

};
tuple<int, double, int,float> a;
```
## 原子类型和原子操作
### 原子操作
原子操作是在多线程中“最小”的操作，不可并行的操作。意味着多线程对共享资源如果是原子
操作的话，那么线程对共享资源的访问是互斥的。
pthread库创建线程，声明互斥锁来保证多线程对于共享资源的互斥访问。
automic_llong 原子类，线程能够对原子类互斥操作。
```c++
#include <iostream>
#include <atomic>
#include <thread>

using namespace std;

atomic_llong total{0};

void func(int)
{
    for(long long i = 0; i < 10000LL; i++)
    {
        total += i;
    }
}

int main(int argc, char** argv)
{
    thread t1(func, 0);
    thread t2(func, 0);
    t1.join();
    t2.join();
    cout << "total: " << total << endl;    

}
```
## 线程局部存储
## 快速退出

# nullptr, delete, default, lambda 新增的特性


# thread 进阶学习
## 特性
* std::thread
需要用RAII的方式去保证Thread对象正常退出，也就是在析构函数中去调用
join或者detach
* std::mutex 锁，线程同步的手段
1. std::mutex 互斥锁，不能递归，不带超时
2. std::recursive_mutex; 递归互斥量，可重入锁，不带超时功能
3. std::time_mutex;
4. std::recursive_time_mutex;
* std::lock
RAII的方式std::lock_guard，std::unique_lock动态的释放锁，std::unique_lock 可以手动释放锁
* std::call_once
保证某一函数在多线程环境中只被调用一次，可以用在单例中
```c++
std::once_flag once;

// std::call_once 配合 once_flag使用
void callOnce() {
  std::call_once(once, [] { cout << "callonce" << endl; });
}
```
* std::condition_variable
用于阻塞一个线程或多个线程，直到有线程通知或者超时才唤醒阻塞的线程
需要配合锁std::unique_lock使用
* std::future
std::future作为异步结果的传输通道，通过get()函数返回线程的返回值
std::promise(value, future)包装值+future()函数
std::packaged_task()包装callback对象+future()函数
```c++
#include <functional>
#include <future>
#include <iostream>
#include <thread>

void func(std::future<int> &f) {
  int result = f.get();
  std::cout << "get future: " << result << std::endl;
  result /= 2;
  std::cout << "value: " << result << std::endl;
}

int main() {
  std::promise<int> prom;
  std::future<int> f = prom.get_future();
  std::thread t(func, std::ref(f));
  prom.set_value(10);
  t.join();
  return 0;
}
```
* async
替代thread的一种异步操作，实际上还是去创建线程操作
封装了packageed_task和promise，future等操作，更加方便。
```c++
#include <chrono>
#include <functional>
#include <future>
#include <iostream>
#include <thread>
int main() {
  // launch async 代表立刻创建线程执行
  std::future<int> f = std::async(std::launch::async, []() {
    //模拟耗时操作
    std::this_thread::sleep_for(std::chrono::seconds(3));
    return 8;
  });

  std::future<void> f2 = std::async(std::launch::async, []() {
    //模拟耗时操作
    // std::this_thread::sleep_for(std::chrono::seconds(3));
    // return 8;
    std::cout << "waiting" << std::endl;
  });
  // 等待3秒之后输出
  std::cout << f.get() << std::endl;
  f2.wait();

  return 0;
}
```

## 条件变量
什么情况下用条件变量来同步呢？
多线程之间共享数据时，当一个线程运行的情况依赖于另一个线程的对共享数据状态变换时，需要
用上条件变量配合锁来达到同步。
当然好像可以使用全局变量标志位来达到目的，但是它不是原子操作。
* 生产消费者问题 Bounded Buffer有界缓冲区
生产者，向Buffer区放入数据。
消费者，从Buffer区取出数据。
如果当Buffer满了呢？ 需要生成者暂停放入数据，消费者取出数据后通知生产者继续运行。
如果当Buffer为空呢？ 需要暂停消费者，生产者放入数据后通知消费者继续运行。
所以需要定义个count来判断Buffer满/空的情况。
### 伪代码
```c++
#include <pthread.h>

pthread_mutex_t mutex;
#define N 100
int count = 0

// 生产者
void procedure()
{
  int item;
  while(true)
  {
    item = produce_item();
    if (queue.size() == N) 
    {
       sleep();
    }
    // 正常的放入数据进缓冲区
    pthread_mutex_lock(&mutex);
    queue.push_back(item);
    count += 1;
    pthread_mutex_unlock(&mutex);
    if (count == 1) // 0->1
    {
      wakeup(consumer);
    }
  }
}
// 消费者
void consumer()
{
  while(true)
  {
    // 看起来没问题，如果当队列为0的时候，准备休眠
    // 但不是原子操作，有可能被打断。
    if (queue.empty())
    {
      this_thread.sleep();
    }
    pthread_mutex_lock(&mutex);
    queue.pop_front();
    count -= 1;
    pthread_mutex_unlock(&mutex);
    if (queue.size() = N - 1)
    {
      wakeup(producer);  
    }
  }
}
```
### 引入条件变量
```c++
#include <pthread.h>
//声明和定义
pthread_cond_t cond = PTHREAD_COND_INITIALIER;
pthread_cond_t* cond = (pthread_cond_t*)malloc(sizeof(pthread_cond_t));
pthread_cond_init(cond, NULL);
```

## C++中线程的同步有哪些方式？
* 互斥锁、读写锁(14/17)、可重入锁/递归锁
* 条件变量+锁
* 信号量——用的比较少


