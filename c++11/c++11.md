# 左值、右值
## 左值 
可以取地址
* 变量名
* 函数名
* "abc"字符串字面量，其他字面量a,1为右值
* 返回 return_type& func()
* ++i, --i; 前置表达式
## 右值
不能取地址
* 纯右值
** 字面量，2.0, 1, 'a'等
** 函数返回值 func();
** i++,i--;
* 将亡值
 即将要消亡的值、要被移动的对象、T&& 函数的返回值、 std::move的返回值
```c++
int a = b+c; // a为左值，b+c为右值

class A{

};

A a;
auto b = std::move(a); //b为将亡值
auto d = static_cast<T&&>(a); // d为将亡值
```
## 移动语言
定义移动构造函数
```c++
class A
{
    public:
        A(int size): size_(size)
        {
            data_ = new int[size];
        }
        A(){}=default;
        A(const A& other)
        {
            size_ = other.size_;
            // data_ = other.data_;  浅拷贝
            // 深拷贝
            data_ = new int[size_];
            memcpy(data_, other.data_[0], other.data[size]);
        }
        // 移动构造函数
        A(A&& a)
        {
            this->data_ = a.data_;
            a.data_ = nullptr;
        }
        ~A()
        {
            delete[] data_;
        }
    private:
        int* data_;
        int size_;
};
int main()
{
    A a(10);
    A c = std::move(a); // 调用移动构造函数

    vector<string> strs;
    vector<string> tmp = std::move(strs);
}
```


# std::function, std::bind, lambda
```c++
#include <functional>
#include <iostream>

//定义一个结构体
struct Foo {
  Foo(int num) : num_(num) {}
  void print_add(int i) const {
    std::cout << "num_+i:" << num_ + i << std::endl;
  }
  int num_;
};

void print_num(int i) { std::cout << "num: " << i << std::endl; }
// 仿函数
struct PrintNum {
  void operator()(int i) { std::cout << "i: " << i << std::endl; }
};

int main() {
  // 定义function包装器，接受返回类型为void,参数为int类型的
  std::function<void(int)> f_display = print_num;
  // 通过包装器调用函数
  f_display(-9);
  // lambda可以直接捕获全局变量
  std::function<void()> f_lambda = []() -> void { print_num(-10); };
  f_lambda();

  auto f = std::bind(print_num, -11);
  f();
  // 接受bind的返回类型，function<>模板实例化中不需要和print_num函数的参数类型一致
  std::function<void()> f_display_12 = std::bind(print_num, 12);
  // f_display_12(); will get error, f_display_12 is void(int)类型
  f_display_12();
  // 实例化Foo类
  const Foo foo(12345);

  //   std::function<void(int)> f_add_display = &Foo::print_add;
  // 绑定类成员函数的时候，在模板实例化时指定类的类型
  std::function<void(const Foo &, int)> f_add_display = &Foo::print_add;
  f_add_display(foo, 1);
  f_add_display(123456, 1);
  // _1占位符表示f_1调用的时候传递过来的参数
  auto f_1 = std::bind(&Foo::print_add, foo, std::placeholders::_1);
  // 必须要传递参数，否则报错
  f_1(0);

  std::function<void(int)> f_add_display_3 =
      std::bind(&Foo::print_add, foo, std::placeholders::_1);
  f_add_display_3(3);

  return 0;
}
```

# thread
```c++

```

# 右值引用的应用——完美转发
引入c++11中的两个概念
* 引用折叠
一旦出现左值引用，优先折叠为左值引用
```c++
typedef const int T;
T& TR;
TR v = 1; v的类型为A& 常量引用
TR& v = 1; v的类型为A& 引用折叠
TR&& v = 1; v的类型为A& 引用折叠

typedef const int T;
T&& TR;
TR v = 1; v的类型为A&&，右值引用，没问题的，引用一个整型的字面量
TR& v = 1; v的类型为A&，引用折叠，左值引用 T&& & -> T&
TR&& v = 1; v的类型为&&, 引用折叠 4个&&->2个&&
```
* 模板对类型的推导
模板函数对类型的推导就比较简单，如果传入的实参是左值 T类型就是T&，传入右值T类型就是T&&。

综合上面两个规则就可以实现完美转发了
```c++

#include <iostream>

using namespace std;
// void runCode(int a) { cout << "值传递调用" << endl; }
void runCode(int &a) { cout << "左值引用传递调用" << endl; }
void runCode(int &&a) { cout << "右值引用调用" << endl; }
void runCode(const int &a) { cout << "常量左值引用调用" << endl; }
void runCode(const int &&a) { cout << "常量右值引用调用" << endl; }

template <typename T> void perfectForward(T &&t) { runCode(forward<T>(t)); }

int main() {
  int a = 0;
  int b = 0;
  const int c = 1;
  const int d = 1;
  perfectForward(a);            // 传入左值
  perfectForward(std::move(b)); // 传入右值
  perfectForward(c);            // 传入常量的左值
  perfectForward(std::move(d)); // 传入常量的右值

  return 0;
}

```

# 自动类型推导 
## auto
## decltype

# 提高类型安全

## 枚举
默认是整数型，所以也可以用宏定义或者const static int Male = 0;这两个其他的方式来定义
enum Gender {Male, Female};
enum {Male, Female}; // 匿名枚举
### 枚举的问题：全局可见性
因为是全局的可见性Type中的General 和 Category的General是一样的，无法编译通过。
```c++
enum Type {General, Light, Medium};
enum Category {General, Pistol}; 
```
### C++ 强枚举类型
* 强类型
* 不会默认等于整型
* 可以指定底层的实现
```c++
enum class Type{General, Light, Medium};
enum class Gategory {General, Pistol};
enmu class Type1 : char {General, Light};
```

## 智能指针——堆内存管理
* weak_ptr
weak_ptr需要用share_ptr去初始化
weak_ptr不增加share_ptr的引用技术，原理是采用一个临时变量去引用share_ptr
weak_ptr没有*,->等重载方法，需要通过lock获取share_ptr,通过share_ptr再去访问。
* shape_ptr
* uniqur_ptr

# 提高性能及操作硬件能力

## 常量表达式
### const 
const 关键字 修饰变量，函数，函数参数，函数返回值等。但是const是运行时候才能确定是不能被修改的量
```c++
// 数组的长度
// 枚举中的值
// switch case中的 case
// 三个都是需要常量值，编译器时期都是需要值
const int getConst() {return 1;}
void const_fun( int  cond)
{
  int a[getConst()]; // 无法通过
  enum {e1 = getConst(), e2}; // 无法通过
  switch (cond)
  {
    case getConst(): // 无法通过
      break;

  }
}
```
### constexpr
* 函数
声明为constexpr的函数条件比较苛刻
1. 单一return返回的语句
2. 函数必须有返回值(不是void)
3. 使用前必须已经有定义
4. return 表达式中不能使用非常量表达式、全局数据。
* 变量
* 类的构造函数
1. 构造函数的函数体必须为空
2. 类的成员变量需要在初始化列表中去初始化，需要用常量表达式
```c++
constexpr int getSize() {return 10;}
const int a = 26; // 运行时常量，一定分配空间
constexpr int age = 26; // 编译器确定的值，如果没有程序使用，也就没有地址分配
constexpr double x = 20.5; 
```
## 变长模板
### 变长函数
c当中使用，c++不建议
### 变长模板类和变长模板函数
```c++
// c++标准库中的tuple
// ...表示该模板是变长的，Elements是模板参数包
template<typename... Elements>
class tuple{};

// 非类型的
template<int... A>
class NoTypeVariadicTemplate{};

// 变长模板，但是有长度限制，因为B声明了是两个类型的模板类
template<typename T1, typename T2> 
class B{};
template<typename... Elements>
class A : private B<Elements...> // Elements... 解包
{

};
A<int,std::string>people; 

// 那么如何想tuple一样可以接受任意多个呢？
// 模板的偏特化
template<typename... Elements>
class tuple; // 声明变长模板
template<typename Head, typename... Tail> // 偏特化定义
class tuple<Head, Tail...> : private tuple<Tail...>
{
  Head head;
}
// 递归的结束边界条件
template<>
class tuple<>
{

};
tuple<int, double, int,float> a;
```
## 原子类型和原子操作
### 原子操作
原子操作是在多线程中“最小”的操作，不可并行的操作。意味着多线程对共享资源如果是原子
操作的话，那么线程对共享资源的访问是互斥的。
pthread库创建线程，声明互斥锁来保证多线程对于共享资源的互斥访问。
automic_llong 原子类，线程能够对原子类互斥操作。
```c++
#include <iostream>
#include <atomic>
#include <thread>

using namespace std;

atomic_llong total{0};

void func(int)
{
    for(long long i = 0; i < 10000LL; i++)
    {
        total += i;
    }
}

int main(int argc, char** argv)
{
    thread t1(func, 0);
    thread t2(func, 0);
    t1.join();
    t2.join();
    cout << "total: " << total << endl;    

}
```
## 线程局部存储
## 快速退出
